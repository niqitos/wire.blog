[{"data":1,"prerenderedAt":569},["ShallowReactive",2],{"$Qv2-HRLKSU":3},{"path":4,"cover":5,"title":6,"description":7,"body":8,"date":559,"tags":560,"authors":563,"readingTime":567,"seo":568},"/7-veb-server-na-esp32-v-arduino-ide",null,"Веб сервер на ESP32 в Arduino IDE","Веб-сервер - це програма, яка приймає та обробляє запити від користувача через веб-клієнт. Веб-клієнтом може бути звичайний веб-браузер на ноутбуці або смартфоні. Зв'язок між клієнтом та сервером здійснюється за протоколом HTTP.",{"type":9,"value":10,"toc":539},"minimark",[11,15,20,23,36,39,43,46,49,53,56,59,63,66,69,72,76,84,88,91,101,105,108,111,114,117,120,124,127,133,136,142,145,151,154,160,164,167,170,176,179,185,188,191,194,200,203,209,212,218,221,227,231,234,240,251,254,260,263,269,273,284,287,293,300,306,309,315,319,322,328,345,351,358,364,368,371,377,381,388,394,398,401,404,407,413,417,420,423,426,429,433,436,442,445,451,454,505,508,514,517],[12,13,14],"p",{},"Клиент отправляет запрос по определенному адресу, а сервер в ответ отправляет веб-страницу или сообщение об ошибке. Например, ошибка 404 означает, что по адресу запроса ничего нет. Веб страницы — это чаще всего HTML-документы.",[16,17,19],"h2",{"id":18},"режимы-работы-esp32","Режимы работы ESP32",[12,21,22],{},"ESP32 имеет 3 режима работы:",[24,25,26,30,33],"ol",{},[27,28,29],"li",{},"режим станции (STA)",[27,31,32],{},"режим программной точки доступа (SoftAP)",[27,34,35],{},"оба одновременно.",[12,37,38],{},"Это обеспечивает возможность построения ячеистых сетей.",[16,40,42],{"id":41},"режим-станции-sta","Режим станции (STA)",[12,44,45],{},"В этом режиме ESP32 подключается к существующей сети WiFi, которую создает беспроводной роутер",[12,47,48],{},"В режиме STA беспроводной маршрутизатор назначает IP адрес ESP32. По этому адресу и идут обращения к веб серверу ESP32. В этом режиме к серверу могут подключатся только устройства, которые подключены к той же самой сети WiFi, что и ESP32.",[16,50,52],{"id":51},"режим-программной-точки-доступа-softap","Режим программной точки доступа (SoftAP)",[12,54,55],{},"В этом режиме ESP32 создает свою собственную точку доступа и действует в качестве хаба, к которому можно подключить до 5 устройств по WiFi.",[12,57,58],{},"В режиме программной точки доступа ESP32 создает новую сеть WiFi с заданным названием (SSID) и адресом IP. По этому адресу к веб серверу ESP32 могут обращаться все подключенные к её сети WiFi устройства.",[16,60,62],{"id":61},"управление-светодиодами-с-esp32-через-веб-сервер","Управление светодиодами с ESP32 через веб сервер",[12,64,65],{},"Для сборки схемы нам понадобятся:\n1. ESP32\n2. макетная плата\n3. 2 светодиода\n4. 2 токоограничивающих резистора на 220 Ом\n5. джамперы\nВажно: убедитесь, что ноги ESP32 расположены по разные стороны макетной платы.",[12,67,68],{},"Подключите анод (+) светодиодов к пинам 4 и 5 через резистор на 220 Ом, как показано на схеме ниже.",[12,70,71],{},"Подключение светодиодов к ESP32",[16,73,75],{"id":74},"как-это-работает","Как это работает",[12,77,78,79,83],{},"Когда вы вводите URL-адрес в веб-браузере и нажимаете клавишу ВВОД, браузер отправляет HTTP-запрос, а точнее GET-запрос, на веб-сервер. В ответ на ваш запрос по данному адресу веб сервер выполнит определенную последовательность действий и вернет HTTP-ответ. Например, мы вводим URL-адрес ",[80,81,82],"code",{},"http://192.168.1.1/ledon"," в браузере. Затем браузер отправляет HTTP-запрос в ESP32 для обработки. Когда ESP32 читает этот запрос, он знает, что пользователь хочет включить светодиод. Таким образом, веб сервер включает светодиод и в ответ отправляет динамическую веб-страницу, отображающую состояние светодиода: ВКЛ.",[16,85,87],{"id":86},"http-сервер-на-esp32-в-режиме-программной-точки-доступа-wifi","HTTP сервер на ESP32 в режиме программной точки доступа WiFi",[12,89,90],{},"Подсоедините ESP32 к компьютеру и загрузите скетч приведенный ниже. Далее я расскажу как он работает.",[92,93,98],"pre",{"className":94,"code":96,"language":97},[95],"language-text","  #include \u003CWiFi.h>\n  #include \u003CWebServer.h>\n\n  /* Название и пароль точки доступа */\n  const char* ssid = \"ESP32\";\n  const char* password = \"12345678\";\n\n  /* Детали IP адреса */\n  IPAddress local_ip(192,168,1,1);\n  IPAddress gateway(192,168,1,1);\n  IPAddress subnet(255,255,255,0);\n\n  // объявляем объект библиотеки WebServer\n  WebServer server(80);\n\n  uint8_t LED1pin = 4;\n  bool LED1status = LOW;\n\n  uint8_t LED2pin = 5;\n  bool LED2status = LOW;\n\n  void setup() {\n    Serial.begin(115200);\n    pinMode(LED1pin, OUTPUT);\n    pinMode(LED2pin, OUTPUT);\n\n    WiFi.softAP(ssid, password);\n    WiFi.softAPConfig(local_ip, gateway, subnet);\n    delay(100);\n\n    server.on(\"/\", handle_OnConnect);\n    server.on(\"/led1on\", handle_led1on);\n    server.on(\"/led1off\", handle_led1off);\n    server.on(\"/led2on\", handle_led2on);\n    server.on(\"/led2off\", handle_led2off);\n    server.onNotFound(handle_NotFound);\n\n    server.begin();\n    Serial.println(\"HTTP сервер запущен\");\n  }\n\n  void loop() {\n    server.handleClient();\n    if(LED1status)\n    {digitalWrite(LED1pin, HIGH);}\n    else\n    {digitalWrite(LED1pin, LOW);}\n\n    if(LED2status)\n    {digitalWrite(LED2pin, HIGH);}\n    else\n    {digitalWrite(LED2pin, LOW);}\n  }\n\n  void handle_OnConnect() {\n    LED1status = LOW;\n    LED2status = LOW;\n    Serial.println(\"Статус GPIO4: Выкл | Статус GPIO5: Вкл\");\n    server.send(200, \"text/html\", SendHTML(LED1status,LED2status));\n  }\n\n  void handle_led1on() {\n    LED1status = HIGH;\n    Serial.println(\"Статус GPIO4: Вкл\");\n    server.send(200, \"text/html\", SendHTML(true,LED2status));\n  }\n\n  void handle_led1off() {\n    LED1status = LOW;\n    Serial.println(\"Статус GPIO4: Выкл\");\n    server.send(200, \"text/html\", SendHTML(false,LED2status));\n  }\n\n  void handle_led2on() {\n    LED2status = HIGH;\n    Serial.println(\"Статус GPIO5: Вкл\");\n    server.send(200, \"text/html\", SendHTML(LED1status,true));\n  }\n\n  void handle_led2off() {\n    LED2status = LOW;\n    Serial.println(\"Статус GPIO5: Выкл\");\n    server.send(200, \"text/html\", SendHTML(LED1status,false));\n  }\n\n  void handle_NotFound(){\n    server.send(404, \"text/plain\", \"Не найдено\");\n  }\n\n  String SendHTML(uint8_t led1stat,uint8_t led2stat){\n    String ptr = \"\u003C!DOCTYPE html> \u003Chtml>\\n\";\n    ptr +=\"\u003Chead>\u003Cmeta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0, user-scalable=no\\\">\\n\";\n    ptr +=\"\u003Ctitle>LED Control\u003C/title>\\n\";\n    ptr +=\"\u003Cstyle>html { font-family: Helvetica; display: inline-block; margin: 0px auto; text-align: center;}\\n\";\n    ptr +=\"body{margin-top: 50px;} h1 {color: #444444;margin: 50px auto 30px;} h3 {color: #444444;margin-bottom: 50px;}\\n\";\n    ptr +=\".button {display: block;width: 80px;background-color: #3498db;border: none;color: white;padding: 13px 30px;text-decoration: none;font-size: 25px;margin: 0px auto 35px;cursor: pointer;border-radius: 4px;}\\n\";\n    ptr +=\".button-on {background-color: #3498db;}\\n\";\n    ptr +=\".button-on:active {background-color: #2980b9;}\\n\";\n    ptr +=\".button-off {background-color: #34495e;}\\n\";\n    ptr +=\".button-off:active {background-color: #2c3e50;}\\n\";\n    ptr +=\"p {font-size: 14px;color: #888;margin-bottom: 10px;}\\n\";\n    ptr +=\"\u003C/style>\\n\";\n    ptr +=\"\u003C/head>\\n\";\n    ptr +=\"\u003Cbody>\\n\";\n    ptr +=\"\u003Ch1>Веб сервер ESP32\u003C/h1>\\n\";\n    ptr +=\"\u003Ch3>В режиме программной точки доступа\u003C/h3>\\n\";\n\n    if(led1stat)\n    {ptr +=\"\u003Cp>Статус LED1: Вкл\u003C/p>\u003Ca class=\\\"button button-off\\\" href=\\\"/led1off\\\">OFF\u003C/a>\\n\";}\n    else\n    {ptr +=\"\u003Cp>Статус LED1: Выкл\u003C/p>\u003Ca class=\\\"button button-on\\\" href=\\\"/led1on\\\">ON\u003C/a>\\n\";}\n\n    if(led2stat)\n    {ptr +=\"\u003Cp>Статус LED2: Вкл\u003C/p>\u003Ca class=\\\"button button-off\\\" href=\\\"/led2off\\\">OFF\u003C/a>\\n\";}\n    else\n    {ptr +=\"\u003Cp>Статус LED2: Выкл\u003C/p>\u003Ca class=\\\"button button-on\\\" href=\\\"/led2on\\\">ON\u003C/a>\\n\";}\n\n    ptr +=\"\u003C/body>\\n\";\n    ptr +=\"\u003C/html>\\n\";\n    return ptr;\n  }\n","text",[80,99,96],{"__ignoreMap":100},"",[16,102,104],{"id":103},"доступ-к-веб-серверу-в-режиме-программной-точки-доступа","Доступ к веб серверу в режиме программной точки доступа",[12,106,107],{},"После загрузки скетча откройте монитор серийного порта со скоростью 115200 бод. Затем нажмите кнопку RESET на ESP32. Если все в порядке, будет показано сообщение о запуске HTTP-сервера.",[12,109,110],{},"Возьмите любое устройство, которое можно подключить подключить к сети WiFi: телефон, ноутбук и т. д. Найдите сеть под названием ESP32. Присоединитесь к сети с паролем 123456789.",[12,112,113],{},"После подключения к сети ESP32 откройте браузер и в адресной строке введите 192.168.1.1. ESP32 должен отобразить веб-страницу с текущим состоянием светодиодов и две кнопки для управления ими. В то же время монитор серийного порта должен отображать состояние выводов GPIO ESP32.",[12,115,116],{},"Теперь нажмите кнопку включения LED1 и следите за URL. ESP32 получит запрос по адресу /led1on, по которому лежит функция переключения состояния первого светодиода. После этого веб-сервер возвращает веб-страницу с обновленным статусом светодиодов. Состояние выводов GPIO также изменится и в мониторе серийного порта.",[12,118,119],{},"Проверьте вторую кнопку. Все должно сработать точно также.",[16,121,123],{"id":122},"как-устроена-программа","Как устроена программа",[12,125,126],{},"Скетч начинается с подключения библиотеки WiFi.h. Эта библиотека предоставляет специальные методы для работы с WiFi на ESP32, например, для подключения к сети. Затем подключается библиотека WebServer.h, в которой есть несколько методов для настройки сервера и обработки входящих HTTP-запросов.",[92,128,131],{"className":129,"code":130,"language":97},[95],"#include \u003CWiFi.h>\n#include \u003CWebServer.h>\n",[80,132,130],{"__ignoreMap":100},[12,134,135],{},"Так как мы используем ESP32 в режиме программной точки доступа, необходимо создать сеть WiFi. Для этого нужно указать SSID, Пароль, IP адрес, IP маску подсети и IP шлюз.",[92,137,140],{"className":138,"code":139,"language":97},[95],"/* Название и пароль точки доступа */\nconst char* ssid = \"ESP32\";\nconst char* password = \"12345678\";\n\n/* Детали IP адреса */\nIPAddress local_ip(192,168,1,1);\nIPAddress gateway(192,168,1,1);\nIPAddress subnet(255,255,255,0);\n",[80,141,139],{"__ignoreMap":100},[12,143,144],{},"Далее объявляем объект библиотеки WebServer, чтобы получить доступ к ее функциям. Конструктор этого объекта принимает порт в качестве параметра. Портом по умолчанию для HTTP протокола — 80. Теперь подключится к серверу можно без указания порта в URL.",[92,146,149],{"className":147,"code":148,"language":97},[95],"// объявляем объект библиотеки WebServer\nWebServer server(80);\n",[80,150,148],{"__ignoreMap":100},[12,152,153],{},"Далее объявляем выводы GPIO ESP32, к которым подключены светодиоды, и их начальное состояние.",[92,155,158],{"className":156,"code":157,"language":97},[95],"uint8_t LED1pin = 4;\nbool LED1status = LOW;\n\nuint8_t LED2pin = 5;\nbool LED2status = LOW;\n",[80,159,157],{"__ignoreMap":100},[16,161,163],{"id":162},"функция-setup","Функция Setup()",[12,165,166],{},"Перед запуском HTTP-сервера нужно его настроить.",[12,168,169],{},"Откроем монитор серийного порта для отладки и установим режим роботы портов GPIO в OUTPUT.",[92,171,174],{"className":172,"code":173,"language":97},[95],"Serial.begin(115200);\npinMode(LED1pin, OUTPUT);\npinMode(LED2pin, OUTPUT);\n",[80,175,173],{"__ignoreMap":100},[12,177,178],{},"Затем указываем SSID, пароль, IP-адрес, IP-маску подсети и IP-шлюз для создания сети Wi-Fi точки доступа.",[92,180,183],{"className":181,"code":182,"language":97},[95],"WiFi.softAP(ssid, password);\nWiFi.softAPConfig(local_ip, gateway, subnet);\ndelay(100);\n",[80,184,182],{"__ignoreMap":100},[12,186,187],{},"Чтобы обрабатывать входящие HTTP-запросы, нам нужно указать, какой код выполнять при запросе по определенному URL. Для этого мы используем метод on объекта server. Этот метод принимает два параметра: URL-адрес запроса и имя функции, которую мы хотим выполнить при запросе по этому URL.",[12,189,190],{},"For example, the first line of below code snippet indicates that when a server receives an HTTP request on the root (/) path, it will trigger the handle_OnConnect() function. Note that the URL specified is a relative path.",[12,192,193],{},"Например, первая строка приведенного ниже фрагмента кода указывает, что когда сервер получает HTTP-запрос по корневому пути (/), он запускает функцию handle_OnConnect(). Обратите внимание, что указанный URL-адрес является относительным путем.",[92,195,198],{"className":196,"code":197,"language":97},[95],"server.on(\"/\", handle_OnConnect);\n",[80,199,197],{"__ignoreMap":100},[12,201,202],{},"Аналогично, нам нужно указать еще 4 URL-адреса для обработки двух состояний двух светодиодов.",[92,204,207],{"className":205,"code":206,"language":97},[95],"server.on(\"/led1on\", handle_led1on);\nserver.on(\"/led1off\", handle_led1off);\nserver.on(\"/led2on\", handle_led2on);\nserver.on(\"/led2off\", handle_led2off);\n",[80,208,206],{"__ignoreMap":100},[12,210,211],{},"Если клиент запрашивает какой-либо URL, отличный от указанных в server.on(), сервер должен ответить с HTTP-статусом 404 (Not Found) и сообщением для пользователя. Для этого используем метод onNotFound() объекта server.",[92,213,216],{"className":214,"code":215,"language":97},[95],"server.onNotFound(handle_NotFound);\n",[80,217,215],{"__ignoreMap":100},[12,219,220],{},"Затем запускаем сервер вызвав метод begin() объекта server.",[92,222,225],{"className":223,"code":224,"language":97},[95],"server.begin();\nSerial.println(\"HTTP server started\");\n",[80,226,224],{"__ignoreMap":100},[16,228,230],{"id":229},"функция-loop","Функция Loop()",[12,232,233],{},"Для обработки входящих HTTP-запросов используется метод handleClient() объекта server. После получения запроса проверяем изменение состояния светодиодов.",[92,235,238],{"className":236,"code":237,"language":97},[95],"void loop() {\n  server.handleClient();\n\n  if (LED1status) {\n    digitalWrite(LED1pin, HIGH);\n  } else {\n    digitalWrite(LED1pin, LOW);\n  }\n\n  if (LED2status) {\n    digitalWrite(LED2pin, HIGH);\n  } else {\n    digitalWrite(LED2pin, LOW);\n  }\n}\n",[80,239,237],{"__ignoreMap":100},[12,241,242,243,246,247,250],{},"Далее создаем функцию handle_OnConnect(), которую мы привязали к корневому URL ",[80,244,245],{},"/"," с помощью ",[80,248,249],{},"server.on",". В начале этой функции установим изначальное состояние обоих светодиодов как LOW (выключены) и выведем состояние в монитор серийного порта. Чтобы ответить на HTTP-запрос, используется метод send(), которому передается код HTTP-ответа, тип контента и сам контент.",[12,252,253],{},"В нашем случае мы отправляем код 200 (один из кодов состояния HTTP), который соответствует ответу OK. Затем указываем тип содержимого «text/html» и вызываем пользовательскую функцию SendHTML(), которая создает динамическую HTML-страницу, и передаем ей состояние светодиодов в качестве параметров.",[92,255,258],{"className":256,"code":257,"language":97},[95],"void handle_OnConnect() {\n  LED1status = LOW;\n  LED2status = LOW;\n  Serial.println(\"GPIO4 Status: OFF | GPIO5 Status: OFF\");\n  server.send(200, \"text/html\", SendHTML(LED1status,LED2status));\n}\n",[80,259,257],{"__ignoreMap":100},[12,261,262],{},"Аналогично, создаем четыре функции для обработки запросов на включение/выключение светодиодов, а так же страницу ошибки 404.",[92,264,267],{"className":265,"code":266,"language":97},[95],"void handle_led1on() {\n  LED1status = HIGH;\n  Serial.println(\"GPIO4 Status: ON\");\n  server.send(200, \"text/html\", SendHTML(true,LED2status));\n}\n\nvoid handle_led1off() {\n  LED1status = LOW;\n  Serial.println(\"GPIO4 Status: OFF\");\n  server.send(200, \"text/html\", SendHTML(false,LED2status));\n}\n\nvoid handle_led2on() {\n  LED2status = HIGH;\n  Serial.println(\"GPIO5 Status: ON\");\n  server.send(200, \"text/html\", SendHTML(LED1status,true));\n}\n\nvoid handle_led2off() {\n  LED2status = LOW;\n  Serial.println(\"GPIO5 Status: OFF\");\n  server.send(200, \"text/html\", SendHTML(LED1status,false));\n}\n\nvoid handle_NotFound(){\n  server.send(404, \"text/plain\", \"Not found\");\n}\n",[80,268,266],{"__ignoreMap":100},[16,270,272],{"id":271},"отображение-веб-страницы-html","Отображение веб-страницы HTML",[12,274,275,276,279,280,283],{},"Функция ",[80,277,278],{},"SendHTML()"," генерирует веб-страницу всякий раз, когда веб-сервер ESP32 получает запрос от веб-клиента. Эта функция просто объединяет HTML-код в большую строку и возвращает его в функцию ",[80,281,282],{},"server.send()",", о которой мы говорили ранее. Функция принимает состояние светодиодов в качестве параметров для динамической генерации HTML-страницы.",[12,285,286],{},"Вначале HTML документа всегда должен стоять — элемент который указывает, что мы отправляем HTML-код.",[92,288,291],{"className":289,"code":290,"language":97},[95],"String SendHTML(uint8_t led1stat,uint8_t led2stat){\nString ptr = \"\u003C!DOCTYPE html> \u003Chtml>\\n\";\n",[80,292,290],{"__ignoreMap":100},[12,294,295,296,299],{},"Элемент ",[80,297,298],{},"viewport"," делает веб-страницу отзывчивой в любом веб-браузере.",[92,301,304],{"className":302,"code":303,"language":97},[95],"ptr +=\"\u003Chead>\u003Cmeta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0, user-scalable=no\\\">\\n\";\n",[80,305,303],{"__ignoreMap":100},[12,307,308],{},"Тег",[92,310,313],{"className":311,"code":312,"language":97},[95],"ptr +=\"\u003Ctitle>LED Control\u003C/title>\\n\";\n",[80,314,312],{"__ignoreMap":100},[16,316,318],{"id":317},"стилизация-веб-страницы","Стилизация веб-страницы",[12,320,321],{},"Добавим CSS для стилизации кнопок и внешнего вида веб-страницы. Шрифт Helvetica, отображение содержимого в виде встроенного блока и выровняем по центру.",[92,323,326],{"className":324,"code":325,"language":97},[95],"ptr +=\"\u003Cstyle>html { font-family: Helvetica; display: inline-block; margin: 0px auto; text-align: center;}\\n\";\n",[80,327,325],{"__ignoreMap":100},[12,329,330,331,334,335,334,338,341,342,344],{},"Далее задаем цвет, размер шрифт и отступы для тегов ",[80,332,333],{},"body",", ",[80,336,337],{},"h1",[80,339,340],{},"h3"," и ",[80,343,12],{},".",[92,346,349],{"className":347,"code":348,"language":97},[95],"ptr +=\"body{margin-top: 50px;} h1 {color: #444444;margin: 50px auto 30px;} h3 {color: #444444;margin-bottom: 50px;}\\n\";\nptr +=\"p {font-size: 14px;color: #888;margin-bottom: 10px;}\\n\";\n",[80,350,348],{"__ignoreMap":100},[12,352,353,354,357],{},"Стилизуем цвет, размер, отступы и границы кнопок. Кнопки ВКЛ и ВЫКЛ должны быть разного цвета, а селектор ",[355,356],"active",{}," создаст эффект нажатия.",[92,359,362],{"className":360,"code":361,"language":97},[95],"ptr +=\".button {display: block;width: 80px;background-color: #3498db;border: none;color: white;padding: 13px 30px;text-decoration: none;font-size: 25px;margin: 0px auto 35px;cursor: pointer;border-radius: 4px;}\\n\";\nptr +=\".button-on {background-color: #3498db;}\\n\";\nptr +=\".button-on:active {background-color: #2980b9;}\\n\";\nptr +=\".button-off {background-color: #34495e;}\\n\";\nptr +=\".button-off:active {background-color: #2c3e50;}\\n\";\n",[80,363,361],{"__ignoreMap":100},[16,365,367],{"id":366},"заголовок-веб-страницы","Заголовок веб-страницы",[12,369,370],{},"Далее выведем заголовок веб-страницы. Вы можете изменить этот текст под вашего приложение.",[92,372,375],{"className":373,"code":374,"language":97},[95],"ptr +=\"\u003Ch1>ESP32 Web Server\u003C/h1>\\n\";\nptr +=\"\u003Ch3>Using Access Point(AP) Mode\u003C/h3>\\n\";\n",[80,376,374],{"__ignoreMap":100},[16,378,380],{"id":379},"отображение-кнопок-и-соответствующего-состояния","Отображение кнопок и соответствующего состояния",[12,382,383,384,387],{},"Для динамического отображения кнопок и состояния светодиодов мы используем оператор ",[80,385,386],{},"if",". Таким образом, в зависимости от состояния выводов GPIO, отображается кнопка Вкл/Выкл.",[92,389,392],{"className":390,"code":391,"language":97},[95],"if (led1stat) {\n  ptr +=\"\u003Cp>Статус светодиода 1: Вкл\u003C/p>\u003Ca class=\\\"button button-off\\\" href=\\\"/led1off\\\">Выкл\u003C/a>\\n\";\n} else {\n  ptr +=\"\u003Cp>Статус светодиода 1: Выкл\u003C/p>\u003Ca class=\\\"button button-on\\\" href=\\\"/led1on\\\">Вкл\u003C/a>\\n\";\n}\n\nif (led2stat) {\n  ptr +=\"\u003Cp>Статус светодиода 2: Вкл\u003C/p>\u003Ca class=\\\"button button-off\\\" href=\\\"/led2off\\\">Выкл\u003C/a>\\n\";\n} else {\n  ptr +=\"\u003Cp>Статус светодиода 2: Выкл\u003C/p>\u003Ca class=\\\"button button-on\\\" href=\\\"/led2on\\\">Вкл\u003C/a>\\n\";\n}\n",[80,393,391],{"__ignoreMap":100},[16,395,397],{"id":396},"доступ-к-веб-серверу-в-режиме-станции-sta","Доступ к веб-серверу в режиме станции (STA)",[12,399,400],{},"Теперь давайте перейдем к нашему следующему примеру, который демонстрирует, как переключить ESP32 в режим Station (STA) и обслуживать веб-страницы для любого подключенного клиента в существующей сети.",[12,402,403],{},"Прежде чем приступить к загрузке скетча, необходимо внести некоторые изменения. Вам необходимо изменить следующие две переменные с вашими сетевыми учетными данными, чтобы ESP32 мог установить соединение с существующей сетью.",[12,405,406],{},"Как только вы закончите, попробуйте набросок.",[92,408,411],{"className":409,"code":410,"language":97},[95],"#include \u003CWiFi.h>\n#include \u003CWebServer.h>\n\n/*Put your SSID & Password*/\nconst char* ssid = \" YourNetworkName\";  // Enter SSID here\nconst char* password = \" YourPassword\";  //Enter Password here\n\nWebServer server(80);\n\nuint8_t LED1pin = 4;\nbool LED1status = LOW;\n\nuint8_t LED2pin = 5;\nbool LED2status = LOW;\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(100);\n  pinMode(LED1pin, OUTPUT);\n  pinMode(LED2pin, OUTPUT);\n\n  Serial.println(\"Connecting to \");\n  Serial.println(ssid);\n\n  //connect to your local wi-fi network\n  WiFi.begin(ssid, password);\n\n  //check wi-fi is connected to wi-fi network\n  while (WiFi.status() != WL_CONNECTED) {\n  delay(1000);\n  Serial.print(\".\");\n  }\n  Serial.println(\"\");\n  Serial.println(\"WiFi connected..!\");\n  Serial.print(\"Got IP: \");  Serial.println(WiFi.localIP());\n\n  server.on(\"/\", handle_OnConnect);\n  server.on(\"/led1on\", handle_led1on);\n  server.on(\"/led1off\", handle_led1off);\n  server.on(\"/led2on\", handle_led2on);\n  server.on(\"/led2off\", handle_led2off);\n  server.onNotFound(handle_NotFound);\n\n  server.begin();\n  Serial.println(\"HTTP server started\");\n}\nvoid loop() {\n  server.handleClient();\n  if(LED1status)\n  {digitalWrite(LED1pin, HIGH);}\n  else\n  {digitalWrite(LED1pin, LOW);}\n\n  if(LED2status)\n  {digitalWrite(LED2pin, HIGH);}\n  else\n  {digitalWrite(LED2pin, LOW);}\n}\n\nvoid handle_OnConnect() {\n  LED1status = LOW;\n  LED2status = LOW;\n  Serial.println(\"GPIO4 Status: OFF | GPIO5 Status: OFF\");\n  server.send(200, \"text/html\", SendHTML(LED1status,LED2status));\n}\n\nvoid handle_led1on() {\n  LED1status = HIGH;\n  Serial.println(\"GPIO4 Status: ON\");\n  server.send(200, \"text/html\", SendHTML(true,LED2status));\n}\n\nvoid handle_led1off() {\n  LED1status = LOW;\n  Serial.println(\"GPIO4 Status: OFF\");\n  server.send(200, \"text/html\", SendHTML(false,LED2status));\n}\n\nvoid handle_led2on() {\n  LED2status = HIGH;\n  Serial.println(\"GPIO5 Status: ON\");\n  server.send(200, \"text/html\", SendHTML(LED1status,true));\n}\n\nvoid handle_led2off() {\n  LED2status = LOW;\n  Serial.println(\"GPIO5 Status: OFF\");\n  server.send(200, \"text/html\", SendHTML(LED1status,false));\n}\n\nvoid handle_NotFound(){\n  server.send(404, \"text/plain\", \"Not found\");\n}\n\nString SendHTML(uint8_t led1stat,uint8_t led2stat){\n  String ptr = \"\u003C!DOCTYPE html> \u003Chtml>\\n\";\n  ptr +=\"\u003Chead>\u003Cmeta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0, user-scalable=no\\\">\\n\";\n  ptr +=\"\u003Ctitle>LED Control\u003C/title>\\n\";\n  ptr +=\"\u003Cstyle>html { font-family: Helvetica; display: inline-block; margin: 0px auto; text-align: center;}\\n\";\n  ptr +=\"body{margin-top: 50px;} h1 {color: #444444;margin: 50px auto 30px;} h3 {color: #444444;margin-bottom: 50px;}\\n\";\n  ptr +=\".button {display: block;width: 80px;background-color: #3498db;border: none;color: white;padding: 13px 30px;text-decoration: none;font-size: 25px;margin: 0px auto 35px;cursor: pointer;border-radius: 4px;}\\n\";\n  ptr +=\".button-on {background-color: #3498db;}\\n\";\n  ptr +=\".button-on:active {background-color: #2980b9;}\\n\";\n  ptr +=\".button-off {background-color: #34495e;}\\n\";\n  ptr +=\".button-off:active {background-color: #2c3e50;}\\n\";\n  ptr +=\"p {font-size: 14px;color: #888;margin-bottom: 10px;}\\n\";\n  ptr +=\"\u003C/style>\\n\";\n  ptr +=\"\u003C/head>\\n\";\n  ptr +=\"\u003Cbody>\\n\";\n  ptr +=\"\u003Ch1>ESP32 Web Server\u003C/h1>\\n\";\n    ptr +=\"\u003Ch3>Using Station(STA) Mode\u003C/h3>\\n\";\n\n   if(led1stat)\n  {ptr +=\"\u003Cp>LED1 Status: ON\u003C/p>\u003Ca class=\\\"button button-off\\\" href=\\\"/led1off\\\">OFF\u003C/a>\\n\";}\n  else\n  {ptr +=\"\u003Cp>LED1 Status: OFF\u003C/p>\u003Ca class=\\\"button button-on\\\" href=\\\"/led1on\\\">ON\u003C/a>\\n\";}\n\n  if(led2stat)\n  {ptr +=\"\u003Cp>LED2 Status: ON\u003C/p>\u003Ca class=\\\"button button-off\\\" href=\\\"/led2off\\\">OFF\u003C/a>\\n\";}\n  else\n  {ptr +=\"\u003Cp>LED2 Status: OFF\u003C/p>\u003Ca class=\\\"button button-on\\\" href=\\\"/led2on\\\">ON\u003C/a>\\n\";}\n\n  ptr +=\"\u003C/body>\\n\";\n  ptr +=\"\u003C/html>\\n\";\n  return ptr;\n}\n",[80,412,410],{"__ignoreMap":100},[16,414,416],{"id":415},"доступ-к-веб-серверу-в-режиме-sta","Доступ к веб-серверу в режиме STA",[12,418,419],{},"После загрузки эскиза откройте последовательный монитор со скоростью 115200 бод. И нажмите кнопку RESET на ESP32. Если все в порядке, он выведет динамический IP-адрес, полученный от вашего маршрутизатора, и покажет сообщение HTTP-сервер запущен.",[12,421,422],{},"Затем загрузите браузер и укажите IP-адрес, указанный на последовательном мониторе. ESP32 должен отображать веб-страницу с текущим состоянием светодиодов и двумя кнопками для управления ими. Если одновременно взглянуть на последовательный монитор, вы увидите состояние выводов GPIO ESP32.",[12,424,425],{},"Теперь нажмите кнопку, чтобы включить LED1, следя за URL. Как только вы нажмете кнопку, ESP32 получит запрос на URL / led1on. Затем он включает светодиод1 и отображает веб-страницу с обновленным статусом светодиодов. Он также печатает состояние вывода GPIO на последовательном мониторе.",[12,427,428],{},"Вы можете проверить кнопку LED2 и убедиться, что она работает аналогичным образом.",[16,430,432],{"id":431},"объяснение-кода","Объяснение кода",[12,434,435],{},"Если вы наблюдаете этот код с предыдущим кодом, единственное отличие состоит в том, что мы не устанавливаем программную точку доступа, вместо этого мы присоединяемся к существующей сети с помощью функции WiFi.begin ().",[92,437,440],{"className":438,"code":439,"language":97},[95],"//connect to your local wi-fi network\nWiFi.begin(ssid, password);\n",[80,441,439],{"__ignoreMap":100},[12,443,444],{},"Пока ESP32 пытается подключиться к сети, мы можем проверить состояние подключения с помощью функции WiFi.status ().",[92,446,449],{"className":447,"code":448,"language":97},[95],"//check wi-fi is connected to wi-fi network\nwhile (WiFi.status() != WL_CONNECTED)\n{\n  delay(1000);\n  Serial.print(\".\");\n}\n",[80,450,448],{"__ignoreMap":100},[12,452,453],{},"Для вашей информации эта функция возвращает следующие статусы:",[455,456,457,460,463,466,469,472,475,478,481,484,487,490,493,496,499,502],"ul",{},[27,458,459],{},"WL_CONNECTED: assigned when connected to a Wi-Fi network",[27,461,462],{},"WL_NO_SHIELD: assigned when no Wi-Fi shield is present",[27,464,465],{},"WL_IDLE_STATUS: a temporary status assigned when WiFi.begin() is called and remains active until the number of attempts expires (resulting in WL_CONNECT_FAILED) or a connection is established (resulting in WL_CONNECTED)",[27,467,468],{},"WL_NO_SSID_AVAIL: assigned when no SSID are available",[27,470,471],{},"WL_SCAN_COMPLETED: assigned when the scan networks is completed",[27,473,474],{},"WL_CONNECT_FAILED: assigned when the connection fails for all the attempts",[27,476,477],{},"WL_CONNECTION_LOST: assigned when the connection is lost",[27,479,480],{},"WL_DISCONNECTED: assigned when disconnected from a network",[27,482,483],{},"WL_CONNECTED: назначается при подключении к сети Wi-Fi",[27,485,486],{},"WL_NO_SHIELD: назначается, когда нет экрана Wi-Fi",[27,488,489],{},"WL_IDLE_STATUS: временное состояние, назначаемое при вызове WiFi.begin (), и остается активным до истечения количества попыток (в результате WL_CONNECT_FAILED) или до установления соединения (в результате WL_CONNECTED)",[27,491,492],{},"WL_NO_SSID_AVAIL: назначается, когда нет доступных SSID",[27,494,495],{},"WL_SCAN_COMPLETED: назначается, когда сканирование сетей завершено",[27,497,498],{},"WL_CONNECT_FAILED: назначается при сбое подключения для всех попыток",[27,500,501],{},"WL_CONNECTION_LOST: назначается при потере соединения",[27,503,504],{},"WL_DISCONNECTED: назначается при отключении от сети",[12,506,507],{},"Как только ESP32 подключен к сети, эскиз распечатывает IP-адрес, назначенный для ESP32, отображая значение WiFi.localIP () на последовательном мониторе.",[92,509,512],{"className":510,"code":511,"language":97},[95],"Serial.println(\"\");\nSerial.println(\"WiFi connected..!\");\nSerial.print(\"Got IP: \");  Serial.println(WiFi.localIP());\n",[80,513,511],{"__ignoreMap":100},[12,515,516],{},"Единственная разница между режимами AP и STA состоит в том, что один создает сеть, а другой присоединяется к существующей сети. Итак, остальная часть кода для обработки HTTP-запросов и обслуживания веб-страницы в режиме STA такая же, как и в режиме AP, описанном выше. Это включает:",[455,518,519,522,525,528,531,534,536],{},[27,520,521],{},"Объявление выводов GPIO ESP32, к которым подключены светодиоды",[27,523,524],{},"Определение нескольких методов server.on () для обработки входящих HTTP-запросов.",[27,526,527],{},"Определение метода server.onNotFound () для обработки ошибки HTTP 404",[27,529,530],{},"Создание пользовательских функций, которые выполняются при нажатии определенного URL",[27,532,533],{},"Создание HTML-страницы",[27,535,318],{},[27,537,538],{},"Создание кнопок и отображение их статуса",{"title":100,"searchDepth":540,"depth":540,"links":541},2,[542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558],{"id":18,"depth":540,"text":19},{"id":41,"depth":540,"text":42},{"id":51,"depth":540,"text":52},{"id":61,"depth":540,"text":62},{"id":74,"depth":540,"text":75},{"id":86,"depth":540,"text":87},{"id":103,"depth":540,"text":104},{"id":122,"depth":540,"text":123},{"id":162,"depth":540,"text":163},{"id":229,"depth":540,"text":230},{"id":271,"depth":540,"text":272},{"id":317,"depth":540,"text":318},{"id":366,"depth":540,"text":367},{"id":379,"depth":540,"text":380},{"id":396,"depth":540,"text":397},{"id":415,"depth":540,"text":416},{"id":431,"depth":540,"text":432},"2025-09-07T00:00:00.000Z",[561,562],"Arduino","ESP32",[564],{"name":565,"avatar":566},"Niqitos","/images/avatars/niqitos.jpg",16,{"title":6,"description":7},1757074884300]